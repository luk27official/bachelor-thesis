\chapter{User documentation}
\label{chap:user_docs}

In this chapter, the user documentation is presented. Firstly, the deployment process is described. We distinguish between two types of users, regular users and developers. We expect regular users to use PrankWeb without modifying the existing code. On the other side, we expect developers to add their own plug-ins or make other changes to the existing architecture. For this purpose, we describe a guide for both types of users.


\section{Deployment}
\label{sec:deployment}

This section describes how to deploy the application. The preffered way is to deploy PrankWeb using Docker. Local development and deployment is limited.

\subsection{Docker deployment}
\label{subsec:docker_deployment}

Firstly, Docker and Docker Compose need to be installed\footnote{Downloadable from the official website at \url{https://docs.docker.com/get-docker/}}. 

After installing Docker, the PrankWeb repository needs to be cloned, preferrably using Git\footnote{Downloadable from the official website at \url{https://git-scm.com/downloads}}.

\begin{enumerate}
    \item Create a directory for the PrankWeb repository and navigate to it.
    \item Clone the repository using the following command:
    \begin{lstlisting}[language=clean]
    git clone https://github.com/cusbg/prankweb.git .
    \end{lstlisting}
    \item Create directories for each of the volumes.
    \item Create mounts for each of the volumes in the \texttt{docker-compose.yml} file. The mounts are created as follows, simply update the \texttt{/tmp/} paths to the paths of the directories created in the previous step:
    \begin{lstlisting}
    docker volume create --name prankweb_rabbitmq --opt type=none --opt device=/tmp/rabbitmq --opt o=bind

    docker volume create --name prankweb_conservation --opt type=none --opt device=/tmp/conservation --opt o=bind

    docker volume create --name prankweb_predictions --opt type=none --opt device=/tmp/predictions --opt o=bind

    docker volume create --name prankweb_services --opt type=none --opt device=/tmp/services --opt o=bind
    \end{lstlisting}
    \xxx{TODO: add docking}
    \item Optionally, create a \texttt{.env} file to change the default variables defined in the \texttt{docker-compose.yml} file. Notice that UID and GID need to have write permissions to the directories created in the previous steps.
    \item Build the Docker images using the following command:
    \begin{lstlisting}
    docker-compose build
    \end{lstlisting}
    \item Optionally, download the conservation database (keep in mind that this database is large, around 30 GB):
    \begin{lstlisting}
    docker-compose run --rm executor python3 /opt/hmm-based-conservation/download_database.py
    \end{lstlisting}
    \item Start the containers using the following command:
    \begin{lstlisting}
    docker-compose up
    \end{lstlisting}
\end{enumerate}

The application is now be accessible at \url{http://localhost:8020/}.

Although the main deployment process will not change much, the best way to get the current information is to refer to the official documentation at \url{https://github.com/cusbg/p2rank-framework/wiki/PrankWeb-deploy-with-Docker}.

\subsection{Local deployment}
\label{subsec:local_deployment}

The local deployment is not recommended, as the support for some components is limited.

The only component that is developed better locally is the frontend (when not considering backend API changes). To run the frontend locally, firstly clone the repository as described in \ref{subsec:docker_deployment}. Then, navigate to the \texttt{frontend} directory.

It is recommended to have a look at the \texttt{server/configuration.js} file to set up the proxy server that will serve potential calls. The proxy service should be running, it is possible to use the default PrankWeb website at \url{https://prankweb.cz}.

This is the default configuration:
\begin{lstlisting}
    // This configuration is used only in develop mode.
    module.exports = {
        // Port used to run-develop instance.
        "port": 8075,
        // Use this to server data from files. Thus, you can develop
        // frontend without the need to run another component.
        //"proxy-directory": "../../data/database/",
        // Use the option bellow to proxy commands to task runner instance.
        // This allows you to run tasks or connect to existing instance (https://prankweb.cz).
        "proxy-service": "https://prankweb.cz",
    }
\end{lstlisting}

After setting up the proxy server, the frontend npm modules need to be installed. This can be done using the following command:
\begin{lstlisting}
    npm ci
\end{lstlisting}

Then, it is possible to run the frontend using the following command:
\begin{lstlisting}
    npm run dev
\end{lstlisting}

The frontend is now accessible at \url{http://localhost:8075/} (with the port specified in the configuration file).

Some of the tools from the executors like P2Rank may work from the command line as used in the Python scripts or Dockerfiles, for more information refer to those.

Official documentation for the local deployment is available at \url{https://github.com/cusbg/p2rank-framework/wiki/PrankWeb-deploy-for-development}.


\section{Regular user}
\label{sec:regular_user}
\xxx{TODO: add some screenshots and a brief description of the UI (when the docking is implemented)}

\section{Developer}
\label{sec:developer}

Developers may modify the existing code to their needs. They may edit any of the existing containers described in \cref{sec:prankweb_arch}. One of the expected changes is to implement custom client-side and server-side plug-ins. The following sections describe how to do that.

Before reading the contents of this section, please familiarize yourself with the topic of plug-ins described in \cref{sec:plugins}.

\subsection{Client-side plug-ins}
\label{subsec:dev_client_side}

Implementing custom client-side plug-ins is simple. The creation may be simplified to the following steps:

\begin{enumerate}
    \item Introduce a new task type in the \texttt{frontend/custom-types.ts} file by adding a new value to the \texttt{ClientTaskType} enum.
    \item Create a new \texttt{.tsx} file, preferrably in the \texttt{frontend/tasks} directory.
    \item In this file, implement a method that will compute the task and returns a \texttt{Promise<ClientTaskData>}.
    \item Implement a method that will render the completed task in the dialog window. This method takes the \texttt{ClientTaskData} as an argument and returns a React component - \texttt{JSX.Element}. An example is shown in \cref{lst:code/client-sample-task}.
    \item Optionally, implement saving the computed volumes at least to a hashmap or implement another sort of caching.
    \item Add the new task component anywhere to be rendered. We suggest adding it to the existing dialog window represented by the \texttt{PocketDialogDetails} component. An example is shown in \cref{lst:code/pocket-dialog-details-client-sample}.
\end{enumerate}

\lstinputlisting[language=JavaScript,caption={An example client-side task (in this case referred to as \texttt{frontend/tasks/client-sample-task.tsx}).}, label={lst:code/client-sample-task}]{code/client-sample-task.tsx}

After this implementation, the client-side plug-in is ready to be used.

\lstinputlisting[language=JavaScript,caption={A modified \texttt{PocketDialogDetails} component including the newly introduced client-side plug-in (\texttt{frontend/viewer/components/pocket-dialog-details.tsx}).}, label={lst:code/pocket-dialog-details-client-sample}]{code/pocket-dialog-details-client-sample.tsx}

\subsection{Server-side plug-ins}
\label{subsec:dev_server_side}


\xxx{TODO: add a brief description on how to add new client/server side tasks, change the current visuals etc.}
